{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { decode } from 'html-entities';\nimport * as base from './base';\nimport { transliterate } from 'transliteration';\nexport const isTrue = value => {\n  return value === base.isTrue;\n};\nexport const isFalse = value => {\n  return value === base.isFalse;\n};\nexport const isNull = value => {\n  return value === base.isNull;\n};\nexport const isEmpty = val => {\n  return val === \"\" || val === null;\n};\nexport const capitalizeWord = value => {\n  return value && value[0].toUpperCase() + value.slice(1) || value;\n};\nexport const makeArrayWithComma = value => {\n  if (value) {\n    return value.replaceAll(/\\s/g, '').split(',');\n  }\n\n  return false;\n};\nexport const objectTransliterate = (obj, keys) => {\n  if (obj && keys) {\n    Object.keys(obj).forEach(key => {\n      if (keys.includes(key)) {\n        obj[key] = transliterate(obj[key]);\n      }\n    });\n  }\n\n  return obj;\n};\nexport const objectMapper = (obj1 = {}, obj2 = {}, mandatoryFields = []) => {\n  let newObj1 = obj1;\n  Object.keys(newObj1).forEach(key => {\n    const value = obj2[key];\n\n    if (value || mandatoryFields.includes(key)) {\n      newObj1 = _objectSpread(_objectSpread({}, newObj1), {}, {\n        [key]: _objectSpread(_objectSpread({}, newObj1[key]), {}, {\n          value: value,\n          isRequired: mandatoryFields.includes(key)\n        })\n      });\n    }\n  });\n  return newObj1;\n};\nexport const objectValueEqualizer = ({\n  obj1 = {}\n}) => {\n  let newObjData = {};\n  Object.keys(obj1).map(key => {\n    const newObj1 = obj1[key];\n\n    if (newObj1.isBase) {\n      if (typeof newObj1.value === 'object' && newObj1.value) {\n        newObjData[newObj1.key] = newObj1.value[newObj1.defValKey] || '';\n      } else {\n        newObjData[newObj1.key] = newObj1.value || '';\n      }\n    }\n  });\n  return newObjData;\n};\nexport const objectDifferences = ({\n  obj1 = {},\n  obj2 = {},\n  labelKeys = {},\n  translate = false,\n  langcode = false\n}) => {\n  let newObj = [];\n  Object.keys(obj1).map(key => {\n    if (obj1[key] !== obj2[key] && obj1[key] !== undefined && obj1[key] !== null && obj2[key] !== undefined && obj2[key] !== null) {\n      newObj.push({\n        label: translate(labelKeys[key].label, false, langcode),\n        newval: obj1[key],\n        oldval: obj2[key]\n      });\n    }\n  });\n  return newObj;\n};\n\nString.prototype.removeHtmlTag = function () {\n  return decode(this.replace(/<[^>]*>?/gm, '')) || this;\n};\n\nString.prototype.htmlEntityToText = function () {\n  let txt = document.createElement('textarea');\n  txt.innerHTML = this;\n  return txt.value;\n};\n\nString.prototype.renderText = function () {\n  return this && this.removeHtmlTag().htmlEntityToText() || \"\";\n};\n\nString.prototype.removeAllSpace = function () {\n  return this.replaceAll(/\\s/g, '') || this;\n};\n\nString.prototype.textOnly = function () {\n  return this.removeHtmlTag().removeAllSpace() || this;\n};\n\nString.prototype.isLangCode = function () {\n  return /^[a-z]+(?:\\.[a-z]+)*$/gm.test(this) || false;\n};\n\nexport const decimalColorToHexCode = number => {\n  //converts to a integer\n  let intnumber = number - 0; // isolate the colors - really not necessary\n\n  let red, green, blue; // needed since toString does not zero fill on left\n\n  let template = \"#000000\"; // in the MS Windows world RGB colors\n  // are 0xBBGGRR because of the way Intel chips store bytes\n\n  red = (intnumber & 0x0000ff) << 16;\n  green = intnumber & 0x00ff00;\n  blue = (intnumber & 0xff0000) >>> 16; // mask out each color and reverse the order\n\n  intnumber = red | green | blue; // toString converts a number to a hexstring\n\n  let HTMLcolor = intnumber.toString(16); //template adds # for standard HTML #RRGGBB\n\n  HTMLcolor = template.substring(0, 7 - HTMLcolor.length) + HTMLcolor;\n  return HTMLcolor;\n};\nexport const formatPrice = (amount, decimalCount = 2, decimal = \".\", thousands = \",\") => {\n  try {\n    decimalCount = Math.abs(decimalCount);\n    decimalCount = isNaN(decimalCount) ? 2 : decimalCount;\n    const negativeSign = amount < 0 ? \"-\" : \"\";\n    let i = parseInt(amount = Math.abs(Number(amount) || 0).toFixed(decimalCount)).toString();\n    let j = i.length > 3 ? i.length % 3 : 0;\n    return negativeSign + (j ? i.substr(0, j) + thousands : '') + i.substr(j).replace(/(\\d{3})(?=\\d)/g, \"$1\" + thousands) + (decimalCount ? decimal + Math.abs(amount - i).toFixed(decimalCount).slice(2) : \"\");\n  } catch (e) {\n    console.log(e);\n  }\n};","map":{"version":3,"sources":["/Users/mata/app-cloudweb/@webcms-globals/helpers.js"],"names":["decode","base","transliterate","isTrue","value","isFalse","isNull","isEmpty","val","capitalizeWord","toUpperCase","slice","makeArrayWithComma","replaceAll","split","objectTransliterate","obj","keys","Object","forEach","key","includes","objectMapper","obj1","obj2","mandatoryFields","newObj1","isRequired","objectValueEqualizer","newObjData","map","isBase","defValKey","objectDifferences","labelKeys","translate","langcode","newObj","undefined","push","label","newval","oldval","String","prototype","removeHtmlTag","replace","htmlEntityToText","txt","document","createElement","innerHTML","renderText","removeAllSpace","textOnly","isLangCode","test","decimalColorToHexCode","number","intnumber","red","green","blue","template","HTMLcolor","toString","substring","length","formatPrice","amount","decimalCount","decimal","thousands","Math","abs","isNaN","negativeSign","i","parseInt","Number","toFixed","j","substr","e","console","log"],"mappings":"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","sourcesContent":["import {decode} from 'html-entities'\nimport * as base from './base'\nimport { transliterate } from 'transliteration'\n\nexport const isTrue = (value) => {\n    return value === base.isTrue\n}\n\nexport const isFalse = (value) => {\n    return value === base.isFalse\n}\n\nexport const isNull = (value) => {\n    return value === base.isNull\n}\n\nexport const isEmpty = (val) => {\n    return val === \"\" || val === null\n}\n\nexport const capitalizeWord = (value) => {\n    return value && value[0].toUpperCase() + value.slice(1) || value\n}\n\nexport const makeArrayWithComma = (value) => {\n    if(value){\n        return value.replaceAll(/\\s/g,'').split(',')\n    }\n    return false\n}\n\nexport const objectTransliterate = (obj, keys) => {\n    if(obj && keys){\n        Object.keys(obj).forEach((key) => {\n            if(keys.includes(key)){\n                obj[key] = transliterate(obj[key])\n            }\n        })\n    }\n    return obj\n}\n\nexport const objectMapper = (obj1 = {}, obj2 = {}, mandatoryFields = []) => {\n    let newObj1 = obj1\n    Object.keys(newObj1).forEach((key) => {\n        const value = obj2[key]\n        if (value || mandatoryFields.includes(key)) {\n            newObj1 = {\n                ...newObj1,\n                [key]: {\n                    ...newObj1[key],\n                    value: value,\n                    isRequired: mandatoryFields.includes(key)\n                },\n            }\n        }\n    })\n    return newObj1\n}\n\nexport const objectValueEqualizer = ({obj1 = {}}) => {\n    let newObjData = {}\n    Object.keys(obj1).map((key) => {\n        const newObj1 = obj1[key]\n        if(newObj1.isBase){\n            if(typeof newObj1.value === 'object' && newObj1.value){\n                newObjData[newObj1.key] = newObj1.value[newObj1.defValKey] || ''\n            }else {\n                newObjData[newObj1.key] = newObj1.value || ''\n            }\n        }\n    })\n    return newObjData\n}\n\nexport const objectDifferences = ({obj1 = {}, obj2 = {}, labelKeys = {}, translate = false, langcode = false}) => {\n    let newObj = []\n    Object.keys(obj1).map((key) => {\n        if(obj1[key] !== obj2[key] && obj1[key] !== undefined && obj1[key] !== null && obj2[key] !== undefined && obj2[key] !== null){\n            newObj.push({\n                label: translate(labelKeys[key].label, false, langcode),\n                newval: obj1[key],\n                oldval: obj2[key]\n            })\n        }\n    })\n    return newObj\n}\n\nString.prototype.removeHtmlTag = function() {\n    return decode(this.replace(/<[^>]*>?/gm, '')) || this\n}\n\nString.prototype.htmlEntityToText = function() {\n    let txt = document.createElement('textarea')\n    txt.innerHTML = this\n    return txt.value\n}\n\nString.prototype.renderText = function() {\n    return this && this.removeHtmlTag().htmlEntityToText() || \"\"\n}\n\nString.prototype.removeAllSpace = function() {\n    return this.replaceAll(/\\s/g, '') || this\n}\n\nString.prototype.textOnly = function() {\n    return this.removeHtmlTag().removeAllSpace() || this\n}\n\nString.prototype.isLangCode = function() {\n    return  /^[a-z]+(?:\\.[a-z]+)*$/gm.test(this) || false\n}\n\nexport const decimalColorToHexCode = (number) =>{\n    //converts to a integer\n    let intnumber = number - 0;\n\n    // isolate the colors - really not necessary\n    let red, green, blue;\n\n    // needed since toString does not zero fill on left\n    let template = \"#000000\";\n\n    // in the MS Windows world RGB colors\n    // are 0xBBGGRR because of the way Intel chips store bytes\n    red = (intnumber&0x0000ff) << 16;\n    green = intnumber&0x00ff00;\n    blue = (intnumber&0xff0000) >>> 16;\n\n    // mask out each color and reverse the order\n    intnumber = red|green|blue;\n\n    // toString converts a number to a hexstring\n    let HTMLcolor = intnumber.toString(16);\n\n    //template adds # for standard HTML #RRGGBB\n    HTMLcolor = template.substring(0,7 - HTMLcolor.length) + HTMLcolor;\n\n    return HTMLcolor;\n}\n\nexport const formatPrice = (amount, decimalCount = 2, decimal = \".\", thousands = \",\") => {\n    try {\n        decimalCount = Math.abs(decimalCount);\n        decimalCount = isNaN(decimalCount) ? 2 : decimalCount;\n\n        const negativeSign = amount < 0 ? \"-\" : \"\";\n\n        let i = parseInt(amount = Math.abs(Number(amount) || 0).toFixed(decimalCount)).toString();\n        let j = (i.length > 3) ? i.length % 3 : 0;\n\n        return negativeSign + (j ? i.substr(0, j) + thousands : '') + i.substr(j).replace(/(\\d{3})(?=\\d)/g, \"$1\" + thousands) + (decimalCount ? decimal + Math.abs(amount - i).toFixed(decimalCount).slice(2) : \"\");\n    } catch (e) {\n        console.log(e)\n    }\n};"]},"metadata":{},"sourceType":"module"}